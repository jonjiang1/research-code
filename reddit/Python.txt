"having just come off a django project, I disagree with authority."
"I prefer pyramid. I have written small projects in both. I teach python and we teach flask because it is easier to wrap your head around, but personally once I started using pyramid I just liked worked with it. I use it for any project I am doing myself. What we tell students when they ask the question is to write a small thing in each one of them and see which one you like more.\n"
"[deleted]"
"What went wrong?"
"Wise words? He's trying to kill our language! \"Roll back some changes to Python 3\"... that's madness! It's like there's a palace coup in the works and now the Javascripties are being brought in as mercenaries. I for one support the BDFL, but once this coup is put down, I hope he swaps places with Linus Torvalds the DFL for a few months. The Linux kernel has never been rewritten in Javascript on his watch. "
"What did you see worth reading? It was madness and insanity designed to saboutage Python, including non-starters like roll back changes from Python 3 (!!!!!!!). This is crazy talk that's never going to happen and a non-starter. "
"This is insanity and madness. Madness and insanity. Then some madness. Then some insanity. This is not how development works.\n\n\"Why are porting?\"\n\"Because there's a new version out.\"\n\nEnd of story. Period. It's a duty of a developer. If you don't have time to refactor your code, you don't have time to create the code in the first place. If you leave code alone it eventually becomes incompatible with something (OS, libraries, whatever) and dies. There's a term for it: bitrot. You have to maintain code to avoid bitrot. Otherwise you incur another term called technical debt. \nhttp://en.wikipedia.org/wiki/Technical_debt\n\nIt's like documentation: it's not about what you gain if you write it. What you lose if you don't is justification enough. \n\nSooner or later you HAVE to port your code. Or freeze it forever on a certain version of python (not a good idea if the code is to have much active development). The longer you wait, the more work there will be - the two codebases aren't going to converge over time. The more lines of 2.x code you write, the bigger your job will be. Thus, like a debt with a huge interest payment, the sooner you pay it the better.\n\nPython3 doesn't need to kiss anyone's a$$ and give the flying ponies that shoot rainbows to entice people to port to it. It paid Python 2.x's technical debt and fixed the language. Now, you port to it. Period. I've never seen another language hand so much to users on a silver platter: from the multi-year support window to backports to 2to3, etc. And a large portion of the community were like Pyjamas' original lead developer: \"Why should I port my code when Python 2 will be supported FOREVER?\" Now that the cutoff date is starting to loom, people who have squandered all the benevolence of the BDFL are screaming about not having had enough time to do something they never started, demanding more features first (which they will no doubt want backported next) and even threatening Python with a fork! \n\nNo more kissing asses. Guido needs to embrace the D in BDFL, channel his inner Linus Torvalds, and open up the Dutch equivalent of whoop-ass! Python has had too much Zen. As Joe Biden explained to Paul Ryan during their debate about setting a firm withdrawal date for Afghanistan, if you don't people will think you're staying forever and never step up. Guido needs a firm date, a steely resolve and a big stick. We've already discussed Python 3.0 - years before it was released. The community has already proposed and accepted the PEP banning any more versions of 2.x. Guido's time machine lets him see your future needs - he's not going to modify it to go backwards to undue all that's been accomplished in the past five years. Instead of pestering him for a 2.8 (a debate that's already over, and lost) the 3.0 Denialists, Refuseniks and Procrastinators need to talk amongst themselves about which of their three options they're going to choose - freeze project, port project, learn a new language and completely rewrite existing code in it. One of those is not like the others, leaving two realistic options - the same two they were given five years ago. It's way past time to choose one."
"I prefer Flask to be honest (more a matter of how the code looks, than functionality), that said I haven't gotten much into Pyramid. Flask for medium/semi large projects and bottle for tiny projects if you ask me - I don't really like Django."
"Brilliant argument in a nutshell - which always takes me a few paragraphs to say. ;-) You've got to port some time or freeze the code, and the longer you wait the higher the  cost. "
"I hope you see that relying on a library that hasn't seen an update since 2007 is a bad idea regardless of the 2/3 issue. Bitrot will set in eventually. That's compelling enough. "
"&gt; Here's how I'd sell it: ... before one of our key libraries drops Python 2.7 support.\n&gt;I don't think this is a good idea.\n\nYou think waiting until something breaks is a good idea?\n\n&gt;Ruby, Java, Perl, PHP, C++ and JavaScript have all somehow managed to \n&gt;introduce new features without telling everyone to rewrite everything in the \"new \n&gt;version\".\n\nPython3 didn't break compatability to introduce new features. It broke compatibility to fix existing ones. Java deprecates but never removes anything and thus it's a gigantically verbose morass with a diagram in its documentation to help users choose which of five different means of opening a file is the right one of any specific occasion. PHP is language design by random number generator and there is a subreddit here devoted entirely to laughing at the bizarre inconsistencies in the language (as well as several classic damning essays). C++ has grown so complex that there are books devoted to discussing \"the good parts\" and talk of companies requiring developers to only develop in subsets of the language. This is the price you pay if you never pay your technical debt. Python is the opposite of those giant, verbose languages. There's a reason people claim Python needs 1/10 the code of Java. Adopting their policies means gaining their drawbacks as well as their benefits, and I don't think anyone wants to turn Python into bloated, stagnant Java. \n\n&gt;All you're managing to do is convince me that Python was the wrong choice.\n&gt; I mean seriously, \n\nNo, you're not serious. Or you're very, very young. Just about everything breaks compatibility sometime. Otherwise you'd still be using DOS or AOL or cassette tapes. When you say \"HOW DARE ANYTHING IN PYTHON EVER CHANGE EVER?!?!\" you may be serious, but I can't take it seriously. Hell, you can't even be guaranteed code written for C++ compiler A will compile on C++ compiler B, yet you're marshalling outrage that Python fixed a broken Unicode implementation five years ago? Really?\n\n\n&gt;they didn't threaten me with code rot; they didn't suggest things that were working \n&gt;just fine are suddenly going to stop working because of something someone else \n&gt;is doing.\n\nIf PHP is telling you things are working just fine... well, there's your problem right there. :-) You do know that Perl and PHP are both working on new versions of their languages for several years now, right? And that they consider them parallel tracks just like Python 3 was to Python 2 and will supplement rather than directly replace the old versions, right? And that in some cases they're even suggesting these changes are so significant they should really be considered a whole new language? And the reason these other languages haven't threatened you with these things is simply that they're so incompetent in design and hard up for good developers that they're many years behind schedule?\n\n&gt;FFS, Programs written for Windows over twenty years ago still run today.\n\nAnd many don't. \n\n&gt;It seems to me that having the open discussion about how Python can fix this\n&gt; would be much more productive than trying to argue with my boss who doesn't \n&gt;seem to like Python that much to begin with.\n\nIt wouldn't be more productive for the Python community, which debated the need for 3.0 in 2006 and the path to migration and proposed and approved a PEP ending 2.x backporting quite some time ago. We've had those debates already. They're over, and no one's getting the keys to Guido's time machine to go back and change them. \n\n&gt; Maybe 2to3 can get good enough we can make it automatic and just have our \n&gt;python2 and python3 coexist transparently. Maybe something similar for the C-\n&gt;library interface. Maybe we backport python3 features to python2 and just pretend \n&gt;python3 never happened.\n\nMaybe lazy developers get off their ass after five years and start porting some code? \n\n&gt;I mean, I get refactoring projects for the point of rethinking algorithms; restating \n&gt;program logic using knowledge and learnings of the running system, but I don't feel \n&gt;comfortable telling my boss we need to rewrite lots of code that we didn't even \n&gt;write, keeping the same algorithm and the same logic, just because python3 isn't \n&gt;compatible with python2.\n\nEverything changes. Even your precious Windows has already announced that all new development of features will occur in the WinRT library, not Win32, and the classic desktop has been reduced to a WinRT application. This should have been explained to your boss 5 years ago - or 7, since we knew 3.0 was coming since at least 2006. \n\nIf you've not explained this fact to your boss yet, that's a major source of the problem. This is something one should have been planning for, just as IT departments have been planning to migrate from XP for quite some time now if they haven't already. Waiting until a year before D-Day then requesting Microsoft continue to support XP despite the 10+ years already given is not a good idea."
"It fixed things. Making Python 3 backwards compatible with the flaws of Python 2 obviates the purpose of Python 3 in the first place. "
"&gt;Which leads to the conclusion not to invest any more time/effort on Python. \n\nOddly enough it didn't lead to the decision to not invest any more time/effort on Python 2.x, did it? This is a fantasy scenario for 3.x Denialists that simply doesn't exist. \n\nDelphi is going through the same nonsense except the users have no control and not much warning but they're protesting before the changes, not after. It's quite a laugh - if you give me immutable strings and memory management I'll take all my code to - to - oh yeah, some other language with immutable strings and memory management that will take a lot more time to rewrite my code to than it would to port my existing code. "
"No. Ignore old tutorials. Don't use ancient libraries. Don't use crappy old IDEs that don't support the current version of the language. Don't uninstall Firefox and switch to Netscape. Don't format your hard drive for FAT32. Only Guido gets to travel through time; don't go back to the past.\n\nI'm a new Python user and I've had no problems. Dive into Python ***3*** and Head First Python, Eric5 IDE, and I choose not to use any module that chooses to harm the future of the language by not having upgraded to the latest version of Python. And I've found things so incredibly awesome that you couldn't pay me to go back to the old language I was using. Pandas, SQLAlchemy, NumPy, SciPy, IPython - Python should be a paradise for research related data analysis. "
"That's only if you're using ancient tutorials. We have plenty of fine books like Dive Into Python 3 and Head First Python. I learned Python with Python 3 and it wasn't bad at all. Eric5 IDE and IPython... all working fine with Python3. Python3 included (but not default) out of the box on my Linux distro. Really everything I need working on Python3 already. It's not bad at all. "
"Pyserial? \n\nSince you will most likely end up sending your commands from a more \"powerful\" computer to a smaller microcontroller, which then carries out the operations. \n\nThis also allows you to have multiple independent loops running on each board - for instance a loop at high frequency that ensures stability on the microcontroller (could be loop making sure that your quadcopter reacts in case of a sudden change in orientation or doesn't crash into the ground when the computer crashes for some unknown reason) and a loop on the computer that does the major calculations (running python) - image recognition, navigation and so on.\nThis is a really good idea, running anything real time on top of an operating system is bound to fail.\n\nConsider watching these video's as a general into on how to build robotics.\n\nhttps://www.youtube.com/watch?v=gGweoLu1Gzo\n\n(maybe) https://www.youtube.com/watch?v=Drk3Dz3_yLE\n\nAlso keep in mind, I am by no means an expert."
"Which website are you crawling and why if I may ask? Every attempt to cut down on the amount of requests should be made if possible."
"It's not stupid, its *inconvenient* on a *development machine*.\n\nIn production, you wouldn't want/need pip installed, so why should it be forced?\n\nAlso, pip is so exceptionally difficult to install as the article points out, you have to first download it, then run the setup script.  OMG, its just too much work!  &lt;/sarcasm&gt;\n\n"
"PyScripter is just an IDE, I think you still need an interpreter (could be wrong though). Try [these instructions](http://www.ics.uci.edu/~pattis/common/handouts/pythoneclipsejava/python.html)"
"People are lazy and work-adverse, and are especially embarrassed by being found caught out at their own shoddy work - so if it becomes easier to hide that than man up and fix it, they'll hide.\n\nThis is what has occurred.  Python 3 was [intentionally backwards incompatible](http://docs.python.org/3.0/whatsnew/3.0.html) hence work is required to port existing code.\n\nThe unicode changes were especially damaging, as popular libraries were caught out at blindly assuming everyone speaks english so encoding/decoding bytes at the network layer was not done - and fixing these issues becomes non-trivial the poorer their code was.\n\nAlso, early versions of Python 3 had lower performance than 2.7 especially due to the need to handle str == unicode; so people who cared that their code ran 0.0004 milliseconds slower railed against Py3 (even if this slowdown was irrelevant in their application - its a perception thing slower == bad)\n\nNow we're at the point where all their previous excuses don't account for much anymore (e.g. library support) they're now finding new ways of whining about Python 3 (it's backwards incompatible!  How dare they make a backwards incompatible major version change and tell us about it 7 years ago!  I haven't found any time during those 7 years to whinge about this also!)\n\nIn short, ignore this vocal minority &amp; enjoy Python 3.\n"
"Since Python can coexist with multiple versions of itself, you've got a number of paths forward:\n\n* [Anaconda](http://continuum.io) (or [miniconda](http://repo.continuum.io/miniconda/))\n* [Canopy](http://www.enthought.com)\n* [RHSCL](https://access.redhat.com/site/solutions/472793)\n* [ActivePython](http:///www.activestate.com/activepython) - currently 3.2 only :(\n* [build it yourself](http://www.python.org)\n\nCore RHEL will remain 6+ years behind the times, the reason they came out with RHSCL is to try to stem the flow of users onto actually supported Linux distributions like Ubuntu which have current software.  If you're stuck in this situation, follow even Redhat's current example and avoid the core system toolchain with one of the options above.\n"
"What's the point?\n\nPython 3 is [intentionally backwards incompatible](http://docs.python.org/3.0/whatsnew/3.0.html).  Even if such a layer was created, the same lazy people would **NOT** port their code to Python 3 but instead just tell people to use Python 2^0.5 forever.  There would be substantial development resources dedicated to this compatibility layer rather than focussed on Python 4 and beyond, crippling Python for the sake of this small band of lazy devs who are in this boat by ignoring the advice and also writing shoddy code to begin with.\n"
"http://en.wikipedia.org/wiki/Comparison_of_open-source_configuration_management_software\n\nScons is great. You might take a look at Baker, docopt, and clint on pypi. \n\nhttp://paver.github.io/paver/pavement.html tasks work similarly.\n\n\"python cli docstrings pypi decorator\""
"&gt; What are you going to do about it, rewrite in a language other than Python 3? That would be even more work, and you'd probably have to retrain all your developers. The entire company would be largely nonproductive for six months or so.\n\nI am *not* proposing we rewrite our python code in another language, but *you are*: Python3 *is* a different language than Python2.\n\nWhat I *am* proposing is that we at least try to figure out how to make them the same language before we resort to selling the rewrite to our bosses. We might have to do that, but I'd rather try everything else first."
"i hope the fuck you are trolling. "
"Those \"flaws\" are embraced by the majority, whereas the \"fix\" is being ignored.  Before release, fix all the flaws you want.  After release, they're features.  "
"The right thing to do is to live with the features the users want, not \"fix\" the language to meet the desires of a handful of language-lawyers."
"I think you need to re-read my reply.  You obviously misunderstood."
"How do you add a feature to 2.8 so that code using that feature still works on 2.7? You couldn't add anything."
"python 2 has first class unicode objects."
"&gt; TBH, I am just trying to make sure that if I go with Flask I'm not going to be in a bind later down the road if/when it becomes time to expand.\n\nYou are not going to be."
"not op but our team just came off a 6 month django project, we'll probably never go back:\n\n- Form. ModelForm? Formset. Inline formset? Model Formset ... ? Jesus I just need data POSTed back. Why must I use your management_form when you don't also give me the JS to ... manage it?\n- ModelForm._meta knows it's app_label, why doesn't a regular Form\n- 200-line migration files are just not fun to grok.\n- ID based migration file names are a pain when multiple devs are involved (Rails / SQLAlchemy solve it using timestamps / SHA1s. South closed it as a wontfix years ago)\n- Having a user model you're not supposed to touch\n- Crippled templates\n- urls.py gets way too disconnected from what they are actually routing to\n- managing 'apps' is silly, making a new directory in python gives you just about the same advantages.\n- `if request.method == 'POST': ...`\n\nIt's true, if you avoid Django you're just going to write 80% of Django, but at least then. It's got the admin going for it. That's about it.\n\nWe weren't even a large team, just 4 developers, but we've come from Ruby, Java, Python and Node backgrounds, using just about any framework no matter how micro or batteries-included, and Django is one we will not look back to.\n\nThere are plenty of other reasons why I don't think Django cuts it, but those are off the top of my head."
"Reddit is built on Pyramid, you can download the source from github if  you want. "
"[deleted]"
"I hate to rag on people's ideas, but I don't see this as very Pythonic. Understand than this is meant to be constructive criticism:\n\n* You redefine a built-in keyword. (file)\n* You give multiple, redundant ways to do things.\n* You've got format strings all over that use magic names. (ie: ones that the user didn't set)\n* Your kwarg `depend` takes different types. (A string or a list of strings)\n\nOn top of that, the presentation of your idea isn't great. An API spec would have been much easier to read than a demo, especially one that's all over the place with incorrect comments."
"Haha, my roommate works for Twitter and was saying earlier that they already have to deal with massive load at midnight."
"- imports are missing: `localStorage` in DataModel and `weba` in ViewModel.\n- `DataModel` repeats `webtodomvcdata` - should be moved to a variable\n  to by DRY\n- imports should be at the top of the file\n- look at [all the logic stuck in\n HTML](https://github.com/skariel/webalchemy/blob/master/webalchemy/examples/todomvc/todomvc.html#L14)\n- are [these javascript\n classes](https://github.com/skariel/webalchemy/blob/master/webalchemy/examples/todomvc/todomvc.html#L300)\n manually or automatically generated? If they are manually generated,\n then you should look at the technology behind\n [muntjac](http://www.muntiacus.org/) which is much simpler and truly\n pure python\n"
"Or just use IFTTT."
"&gt;In production, you wouldn't want/need pip installed, so why should it be forced?\n\nThen what about this approach? pyvenv-3.3 doesn't install pip by default, nothing is forced. But if you add a switch, e.g. --add-pip, pip is also installed. Now your life is made easier and you don't need to use virtualenv. Wouldn't it be better?"
"Looking at this someone needs to dethrone java.  Don't care if it's python or someone else but it has to be done."
"&gt; The PYPL PopularitY of Programming Language Index  is created by analyzing how often language tutorials are searched on Google : the more a specific language tutorial is searched, the more popular the language is assumed to be. \n\nHoly shit that sounds like a rubbish metric."
"It'll be a while. Especially because a lot of colleges teach it as their first language. "
"Why? "
"out of the 2 you list, gunicorn is the only one that is a wsgi server and thus can serve/run a python app. vagrant is a tool for managing virtualbox images, it has nothing at all to do with python."
"[deleted]"
"What do you propose instead? "
"PyPHP?\n\n\n(don't downvote me)"
"&gt; Python is the Language of the Year, according to some random guy from the internet who takes the trends for \"$language tutorial\", disregards foreign languages, discards possible name collisions, limits the results to the top ten, and even then picks second place because it made the most improvement in one year.\n\nFTFY"
"[deleted]"
"When I went to college my first time (for programming) it was for VBasic and C.\n\nThings can change.  VBasic is dead."
"I know, just wishful thinking."
"I'd wager in the next 5 years ObjC might start coming close. That all depends, it's a relatively new language - but in the past 3 years it's gained a huge share."
"Awesome work !!!"
"I love python, but what does that even mean? I don't think such a 'metric' will attract new users. "
"It measures uptake reasonably well, at least relatively rather than absolutely. "
"I much prefer the [TIOBE approach](http://www.tiobe.com/index.php/content/paperinfo/tpci/tpci_definition.htm), although that has issues as well.  I don't think there's a lot of value in popularity listings beyond \"these languages are pretty widely used\", and PYPL seems to measure something else entirely.  The number of people fumbling around with tutorials isn't necessarily related to the number of people actually using it."
"It means that you prefer a lagging indicator.  PYPL is a [leading indicator](http://en.wikipedia.org/wiki/Leading_indicator#Leading_indicators)."
"They can change, but it will take time I think.  Then again I'm no expert on language trends. "
"It's from 1983 making it *older* than most languages in that list. Apple gave it a new lease on life. \n\nSee: http://en.m.wikipedia.org/wiki/Objective-C"
"That's right, Jobs and his team of engineers adopted the language after he got fired from Apple to use on NeXT.\n\n\nNot sure why I didn't remember that."
"It means people are learning Python and need help with it more frequently than they are other languages. As with all statistics the precise meaning is open for interpretation. It could mean Python is harder to learn than lower ranking languages and easier than higher ranking ones. Without a few more data points it's hard to draw solid connections but I would be confident this indicates significant increase in use. I would not trust comparisons between languages based on solely these numbers. "
"I don't think we can draw meaning from it at all. Could just be more projects, etc. "
"What is being done in Python that isn't being done in other languages like Java?  Is there a specific set of libraries driving popularity?  What spaces do these libraries serve?"
"Not to shit on anyone's parade but it looks like a clean fork and reskin of https://paste.buttscicl.es/"
"Its just my opinion but from my prespective java is slow at changing. Still no lambda expressions (coming march 2014) modules coming on jdk9, date api sucks (being replaced in jdk8 if im right) gui framework sucks(being replaced too). Its been slow to change.\n\nThats why clojure scala groovy etc exist. The jvm is good, performance is fine, ecosystem is fine but the language needs improvements in many different ways. Like the theory of evolution says its not the strongest or smartest who survives but the one who keeps changing. \n\nNow all languages have prons and cons and i believe all of them have a usage. The purpose is not to start another language war, that's just what i think about java.\n\n"
"I was talking with some of my college professors and they asked me about changing our intro class from Java to Python. So it is definitely starting to change (I actually voted against that change, but that's sort of a long story)"
"I'm mostly not convinced that it's a sufficiently accurate metric of popularity at all.  Using this indicator suggests an assumption that for each language a similar relative amount of people actually ends up *doing* something with it."
"fanfiction.net to rank fanfic by popularity"
"I don't know how much it's driving popularity, but scientific computing support is just awesome in Python. I've found Python and its scientific package ecosystem to be a magnitude better than any other language/ecosystem."
"Hey thanks for the response!  If you don't mind my asking, what packages/libraries in particular? "
"We chose Pyramid over Flask...and Django.\n\nDjango - \nWe use Django for standard websites. For pure CRUD with little customization Django is a nice convenience. Once a more customized experience creeps in, it begins to become irritating. Url's and redundant file structure are pains from a project level construct. Many items do not fit in an app and you are left juggling a nomenclature that is forced around a construct that may or may not make any sense once the project has matured.\n\nThe Django admin can be nice on one hand and a pain on another. Quick changes to a model while developing and you need to go update the admin, etc... Just another thing to have to keep tabs on. Then there is the need for managers within the ORM as well as the separation of InclusionTags from their use within say the global template library. Things can get strewn across the project relatively easy and it is somewhat clumsy in the ability for you to force your own structure on top of it.\n\nFlask - \nWe looked at it for its strength supporting  a JSON api structured project. While it is light and wasy to get going we found a few issues that we had dealt with in Django. The main one was the idea of Blueprints. We felt that it to be a big \"App\" like within the Django environment. Not nearly is prescriptive but a structural norm which may or may not make sense in our project construct.\n\nThat being said we had a nice time getting a Flask instance up  dancing with MongoDB in no time flat. There seems to be more batteries with Flask than with Pyramid from my inspections. They are not tightly coupled but are norms within the community and could easily be considered coupled, such as the Flask admin, Flask mongoengine, Flask version of anything Django does, etc.\n\nFlask seemed to be what Django could be if it were liberated of all the constructs that make Django \"accessible\" which actually end up confusing things. Flask gets out of your way, but its community and its ecosystem can easily get you there with tools made to plugin right in to Flask.\n\nPyramid -\nWe love Pyramid. To us, Pyramid is Python. Almost every convention or issue we have had to learn, consume, rationalize, wrap our heads around has resulted in us realizing it is done just the way you would do it in Python. No tricks. No special cases. Pure openness to the rules that already exist.\n\nAnd while the community is smaller in numbers on Reddit and SO, I have found them to be very responsive on IRC. Actually, I have had more questions answered in a constructive, helpful and timely fashion with the Pyramid community than any other. It was part of the reason we were able to get up to speed so fast. With Django things would be helpful but not specific to what one may be doing. i.e. you may be resolving problems that have crept up in many difference ways so as the answer may have been answered but not in a directly logical way from the condition in which one may be experiencing it. With Pyramid it is not so esoteric.\n\nWant a module, plug it in. Want nested modules within a view package. go ahead. Want to attach a whole new package with self contained routes, go ahead. Want a single reusable template library that can fetch data without needing to render to its own separate template (inclusion tags django?), go right ahead.\n\nMost of what makes Pyramid nice to us is that it has taken care of what is many of the headaches and stepped away from the places where individual need might determine a unique use case. Everything is easily extended as well as battle tested. If you want some hand-holding or some weight lifting you can use scaffolds. But they by no means define a structure that is imperative to the function of the overall project...just help connect some boiler plate. Rearrange as needed.\n\nIt deals with routes somewhere between Flask and Django. It pushes no template language, no ORM, no session store, etc. But can plug them in easily in a standard method that Python libraries plugin. The really only Pyramid specific concern is the Config object...but that is a positive from my perspective.\n\nWe are using Pyramid to spew to templates (mako) , return JSON (from apis and mongo), \nsqlalchemy and pymongo(who needs a mongo orm?), some nice template tools with webhelpers for the web served side. Lots of access to tools that are not easy to integrate into a Django project. \n\nWe could do all the same with Flask and considered the possibility heavily.\n\n---\nI am sure one could do a project in either Flask or Pyramid and have very similar results using basically the same tools. It is merely a choice of what one is comfortable with.\n\nBest of Luck!!!\n\n*edit - spelling"
"i move from java to py for many reasons. This are the basic ones\n\n1) I used to code java on my free time. when i started python i found out that i could do things much faster. and after work you may have 3 hours to code. you want to get things done as fast as possible.\n\n2) lambda expressions, first class functions,decorators, list comprehensions, cleaner code, generators, more freedom(e.g. can overload operators)\n\n3) In general Standard library is better. take for example itertools\n\n4) Lot of nice libraries that allow you to do your job in much less code     e.g. a) flask,bottle can have a web app in 4 LOC no xml config or whatever. b) requests i can just send an http request in 1 line in the interpeter and it saves me time. text-blob, scikit-learn etc..\n\n5) Culture "
"I can pretty much guarantee that the scipy stack will be the main one."
"Isn't Celery a little overkill?"
"[deleted]"
"&gt; At the end of the day, it is a balance\n\nI totally agree. I believe all languages are useful if they didn't keep backwards compatibility they wouldn't be so popular.\n\n I am aware of joda time is the same principle with groovy i think. If there's a feature that people really want and can't get they will just do it. \n\nIn general i agree 100% with what you said. All languages have good and bad things you choose depending on what you prefer. The only problem is when you don't actually choose (e.g. go to uni learn java because that's what they teach do it for money without having an opinion, in general don't care about programming just do it)\n\n"
"Ooh ooh! Storytime! "
"Yes, but that seems like a reasonable assumption."
"[deleted]"
"Yes i don't disagree. Java will easily get you a job. But a good programmer will also learn other languages. Say i go to school they teach me christianism. Well the principles of christianism if i follow they would make me a better person. But studying buddhism gave me a different perception and would still make me a better person."
"OK so this is the python sub so I feel that I do need to preface this with I really do like python a lot. \n\nThat said there are a few flaws with teaching it as a first language and especially as a first language at my school. \n\nIn general :\n\nPython protects you from a lot. Too much, in my opinion, for someone just learning programming when they will go on to more languages. For example, dynamic variable types. It protects the programmer from making a conscious decision about what the variable needs to be. That means the programmer doesn't see a difference between a char and a string or an int and a double. These are important distinctions to be made later on if you learn python first. \n\nThere are a few other issues with python as a first language but I'll leave those out. The main issue is that it complicates later languages because it is so easy. So it's great for people who won't learn another language but not so much for those who will. \n\nWhich leads into the problem for my school particularly. We have three main intro classes \n\n- intro to programming ( java) \n\n- object oriented programming (java) \n\n- data structures (C++) \n\nThe issue with the third class is that a good chunk of the class is dedicated to teaching C++ rather than data structures. Now the issue with changing the first class is the administration isn't willing to change the second class to python as well, so that means in three subsequent classes, the student loans three fairly distinctive languages. And as I pointed out about the third class, learning a new language is one of the most time consuming parts, so it makes sense to stay at least fairly consistent in the languages. Java is enough like C++ (I agree completely that data structures should be in C++) that that transition is not that complicated, but python differs fairly significantly from C++. \n\n"
"I would say sysadmin and operations work is also driving its popularity. "
"Not necessarily; I was taught python as a first language at university - during which time I had to google for a lot of tutorials! I've hardly ever used it since. "
"[Numpy](http://www.numpy.org/), [scipy](http://www.scipy.org/), [matplotlib](http://matplotlib.org/), [pandas](http://pandas.pydata.org/), [skikitlearn](http://scikit-learn.org), [sympy](http://sympy.org/en/index.html), and [iPython](http://ipython.org/)â€’particularly the [iPython Notebook](http://ipython.org/notebook.html)."
"I'd say it's a better metric for future growth than extrapolating from TIOBE Index data. But it's a piss-poor metric for overall popularity."
"Did you take any statistics courses while you were there?"
"On the flip side making people learn Java first increases the number of people who just \"don't get\" writing code and aren't interested in the meager pay-offs for their time."
"Definitely, but we don't have much of an issue with that at my school. My proposal was to have two intro classes, one that is in python and one for Java. That way one is for majors (java) and one is for non majors (python). If a non major decides to continue on, they could just jump into the second Java class. "
"No, it's one reasonable metric.  The problem is that you need multiple metrics to evaluate most things.\n\nImagine choosing a car based on just a single metric.  Doesn't work.\n\nBut, this is a reasonable one to include."
"Python is the most liberal language I have met. When you say language-lawyers, I can think of Java for instance. IMO Python is evolving in the right direction."
"Git is an SCM, basically you can use it to version control your software. I'm really bad at explaining, so hopefully this is useful for you http://git-scm.com/book"
"[deleted]"
"&gt;What I am proposing is that we at least try to figure out how to make them the same language before we resort to selling the rewrite to our bosses. We might have to do that, but I'd rather try everything else first.\n\nI agree, actually, but PSF doesn't seem to be on-board yet."
"Well because it has the letters \"PY\" in the name, for a start :)"
"I'm working my first job in Django (Python web framework) after getting a CS degree (Java, C++), and I have 2 favorite parts. First, its super simple. Never programmed in a scripted language before but I love it. Second, its dynamic, no class definitions or anything. Add variables as needed! I would say, 100% yes add it to your toolbox.\n\nAlso you can download ipython to give it a whirl.\n\nWish I could be more in depth but I'm still up from new years."
"Curious, is your program setup in quarters or semesters?  How do you teach java without teaching object oriented programming?  BTW I would recommend non-majors to learn JavaScript over any other language. "
"to be fair some times its a positive thing, because people abuse freedom. It doesn't allow multiple inheritance either. But i'm preety sure if those features were allowed some people would misuse them. I personaly consider python a \"more free\" language. Not saying is positive or negative. It's preference"
"I agree wholeheartedly.  \n\n"
"I prefer to work on a Mac, but my day job had me working with C# in Visual Studio and I *loved* it.  You're unlikely to find an IDE for Python that is better than VS.  For this reason, you should consider [IronPython](http://ironpython.net/) and [Python tools for Visual Studio](http://pytools.codeplex.com/).  Going this route will let you leverage your knowledge of VS and C#'s libraries and make it easier to integrate Python code in your projects.  Should you ever need to make your projects cross-platform [the Mono project](http://www.mono-project.com/Main_Page) will let you develop and execute on Linux and Mac machines.  So far, I've only sold you on VS and the CLR (technology behind C#) and not on Python.\n\nIf productivity is crucial, Python is for you.  For one, the syntax is easier to learn than C.  So if you learned C#, you can learn Python.  You don't have to learn *all* of the syntax at once.  Learn the basics of defining functions and using builtin types like dict and list.   For two, Python has an interactive prompt which is *great* for trying out a snippet of code, getting it to work, then pasting it into your source file.  Finally, the Python community is as vast/global as Python's libraries.  So it's easy to get help online at nearly any time of day."
"I would not be surprised if there were more library coverage for python than any other language. Many things are built-in. \n\nPerformance is not comparable to c for data crunching. However, you can drop down to c(++) for parts, and many data-processing modules do so. \n\nThere are some ides, but since I'm philosophically against them, I can't comment on how \"good\" they are. There are a hell of a lot of people using the language, however. \n\nPython's gains come mostly from making sense; there's a tendency to see the python approach to a problem and wonder why everyone else isn't doing that. It's straightforward, with a focus on good documentation, and that makes for a better programming experience. "
"My school did the same thing, but they decided to also have the Data Structures I class be Python, and the Data Structures II class remained C++."
"&gt; Git is an SCM\n\nThat isn't really very helpful."
"It's semesters. \"Object oriented programming\" is learning about the design of objects and how they interact. Generic programming, UML, etc. \n\nJavaScript would make sense for non majors who are going into web design but most of our non majors are mechanical engineering who want programming before taking control systems (which is why my idea was rejected - there is a C non major course already)"
"I too am a mechanical engineer, and use python (with some c interspersed) for almost all of my simulation, analysis, and computation.\n\n**Good things:**\n\n1.) **Writing Speed**: Writing code in python is super fast, saving you time. There's a library for most everything you could think of doing. If it's not in the standard library, it's only a [pip](http://www.pip-installer.org/en/latest/) away.\n\n2.) **Execution Speed**: Even though it's interpreted, in most cases python is fast enough that you don't care. And if you need it to be faster, you can write code in c, and wrap it in python using a variety of librarys (I prefer [ctypes](http://docs.python.org/2/library/ctypes.html)). Or write it in [cython](http://cython.org/).\n\n3.) **Free**: It's all opensource, so it's free. If you're making things to sell you may need to work around liscensing, but for in company tools this is a plus.\n\n4.) **Science**: You're an engineer, so I assume most of what you're doing is computational. Here's what I (and most people) use:\n\n* [Scipy](http://www.scipy.org/) - Scientific computing\n\n* [Numpy](http://www.numpy.org/) - Array and Matrix routines. Base for almost all scientific computing in python. Written in C, so it's *fast*.\n\n* [Sympy](http://sympy.org/) - Symbolic computation. Need to calculate a complicated integral? Don't use Mathematica/maple, this works just as well.\n\n* [Matplotlib](http://matplotlib.org/) - Publication quality plotting library.\n\n* [Ipython](http://ipython.org/) - Interpreter on steroids. Great for interactive computation. The [notebook](http://ipython.org/notebook.html) is the killer feature. Mix code, text, and figures all in one file. I use it for data analysis. Pull in the data, run the code to analyze it. Generate plots (inline). And discuss the results. Need to send a report to your boss? [Ipython nbconvert](http://ipython.org/ipython-doc/rel-1.0.0/interactive/nbconvert.html) can format the notebook into a publication quality LaTeX file or html file, among other things.\n\nOther libraries with more focussed interest, that you may be interested in:\n\n* [Python Control](http://sourceforge.net/projects/python-control/) - If you're doing controls work, this is similiar to Matlabs control package. It's not maintained as much as I'd like, and is missing some things, but overall it's a good library\n\n* [Pyqtgraph](http://www.pyqtgraph.org/) - Matplotlib makes pretty plots, and is *the standard* plotting library. But it's slow. Need realtime plots? Use this. I'm pulling in 6000 points a second, and plotting them in realtime, without issue. Great library.\n\n* [Pyside](https://pypi.python.org/pypi/PySide) - Coupled with the above, if you need a GUI this is a good library to start with. Bindings to the Qt framework. There's also [pyQt](https://wiki.python.org/moin/PyQt) which is a different set of bindings. If you're more familiar with wxWidgets, [wxPython](http://wxpython.org/) is pretty popular as well. There's not really a best one, it's more preference here on what to use.\n\n**Bad things:**\n\n1.) **Packaging**: It's a mess. Writing something on your computer, and trying to get it to work on a different one isn't always the easiest thing to do. [This tutorial](http://www.scotttorborg.com/python-packaging/) is pretty good.\n\n2.) **Versions???**: Python 3 is not backwards compatible with Python 2, breaking lots of things and making many people unhappy. For new things, you're recommended to go with 3, and most (but not all) libraries have been ported. Python 2 isn't going away anytime soon though, so you'd be fine working in that. Just need to make sure everyone is consistent if you're sharing code.\n\n3.) **Multitasking**: The infamous [GIL](http://en.wikipedia.org/wiki/Global_Interpreter_Lock) issue. The python interpretter can only ever do one thing at a time. Even with threads, it's just switching back and forth quickly, not truly multitasking. For most things this doesn't matter. And python makes it super easy to use processes with [Multiprocessing](http://docs.python.org/2/library/multiprocessing.html) that this can be gotten around trivially.\n\n**Final Verdict**\n\nAll in all, python is an excellent language, and I highly recommend it to anyone in an engineering career. While matlab and .NET seem to be the standard for in-house tools these days, there is definitely a shift towards opensource tools. The community is huge and very supportive, and as outlined above there are plenty of scientific tools at your disposal to do virtually anything you'd need to do. The few issues with the language I mentioned above can be worked around, and for the most part don't get in your way. Definitely something worth adding to your toolbox."
"Object oriented programming is a general concept, and I think it can be tought well with any language that implements it decently. Hell, you could teach people extremely decent OOP with PHP if you wanted to.\n\nI think the best breadth of programming to achieve is to learn the practical experience of programming with both dynamic and static languages. Pick your ideal one from each. It still comes down to preferences, mine would be C and python. C because you can get past learning the syntactical / structural elements of the language much faster than Java / C++. Python is just super clean and practical.\n\nAlso something to be said for practicing programming with and without memory management. I especially am sad for many Java programmers who wouldn't have the foggiest what to do without a JVM. "
"Check out [sage](http://www.sagemath.org/) as well, for a does-freaking-everything-mathematical sorta python distribution."
"I'd suggest taking 15 minutes or so and running through http://try.github.io/levels/1/challenges/1.  It is a decent walkthrough for those with little version control experience."
"You're right but designing a set of objects is different when doing it in Java vs Python. And everything you learn about designing them in Python is also the case in Java but not reverse is not necessarily true. So by learning Java, learning python is much easier but learning Python doesn't solve some of the issues of learning Java. "
"Another problem with the metric: it's based on what _newbies_ call things. Take ruby for example. I'm suspicious that it's so low. I suspect it's because most people searching for tutorials are actually searching for _rails tutorial_."
"My first University CS class was actually an \"Intro to Programming\" type class that used python.  The argument in favor of Python (as given by the professor) was essentially that the 'protection' many feel to be detrimental is actually beneficial as Python 'gets out of the way' and lets students focus more on CS than language details and syntax.  The class introduced types briefly (only explaining what they are and that python 'manages' them for you), but spent most of the duration focusing on control structures/conditional statements, boolean logic, functions, recursion, simple tracing, libraries, etc.  I've seen programs that do something similar using psuedocode, but personally feel the use of python was advantageous as it allowed for simple testing and experimentation. \n\nThe following class, first in the CSE major track, was somewhat similar, but in greater depth, and added lower level concepts (memory management, stack/heap, pointers, structs and basic software design elements) using C.  Following that was OOP then Data Structs in C++.\n\nI found my school's program to be rather logical and linear and avoided the pitfalls of learning multiple languages until later on, once core concepts were fairly well understood and differences between languages could be better appreciated.  Python provided me a fairly good foundation to learn on (though as mentioned, it was optional at my school), but the focus was less on the language and more on the core concepts of basic CS.  I don't necessarily think it would be a good core requirement, and definitely wouldn't serve well as a replacement to any of the other classes you or I mentioned, but it can have a useful place ime."
"Thanks for the feedback. I'll respond to each of these in turn.\n\n1. By convention, people use `open` over `file` - I've never used the `file` object directly. It's even been removed in python3.\n2. I definitely do have some redundancy here. I thought a lot about how to do dependencies with a single method, but they all break down for various reasons. I'll reply to this with some considerations I did.\n3. I definitely am using some magic to do those format strings. (Plan to implement in with voodoo from inspect module). However, including the argument seems like too heavy of syntax.\n4. I think this is okay. It seems annoying and redundant to do func([arg1, arg2]) if func(arg1, arg2) can be used instead.\n5. I looked it over and you're absolutely right. I'll update with a easier to understand version.\n"
"Can you use all of them together? I thought pandas, skikitlearn, and sympy were incompatible. I have the rest of them installed."
"As mentioned, Obj-C is not new -- It's gained popularity as a result of Apple's commercial success with iProducts,  but it's definitely not new.\n\nTotally tangential, but I just don't find the smalltalk syntax to be very enjoyable. Admittedly, I have very little experience with Obj-C so I reserve the right to change my opinion when I am less naive."
"And to use most libraries, you need to downgrade your unicode strings to a plain str."
"See I actually argued for the reverse. Learn the hardware low level stuff relatively early on, then when you get to complicated material (algorithms, AI, security, automata, etc) you don't have to concern yourself with minor details like pointers, memory management, etc. Early on, it's a lot easier to work with pointers because your projects are simpler. But later, the focus isn't on \"programming\" it's on computer science. "
"thanks :)"
"Where's perl on that list? Just wondering."
"nope I did not clone that. I made a new one following https://github.com/mitsuhiko/flask-pastebin I hope that clears away all the misconceptions :)\n\n__EDIT:__ secondly most of the pastebins give same functionality so it is not difficult to confuse their source codes with each other. Mine one now supports diff as well and I am adding new functionality as I write this post."
"&gt; Your bosses are wrong. Switching to Python 3 is a textbook example of eliminating technical debt. \n\nRight. And if your boss is any good he will then ask about the wisdom of choosing (and now staying with) python in the first place... Alternatively, he may not even ask, but on your next project you will be told not to use python.\n\nThis is a very bad battle to fight..\n\n\n"
"My thoughts on what I considered for the 'depends' action.\n\nhttp://pastebin.com/WVhvF6sQ"
"Git is amazing. Not only is it used for version control but you can have your application on a local git repo or on your GitHub account and easily clone it between systems for deployment or dev.  As /u/SerpentSix said, check out that link to get a QuickStart on it.  It's super easy to use.\n\nI also recommended dabbling with Linux. Not only because its developer friendly but it's ,much cheaper in the long run.  Hosting applications on windows servers can be pretty expensive at most hosting companies.  I started programming on windows too but a friend told me to give linux a go, best advice ever.  I will only develop on my Linux boxes."
"&gt; channel his inner Linus Torvalds\n\nFunny that you mention Linus Torvalds.. You do know Torvald's opinion about backward compatibility? No? Then google for it. Hint: he is **adamant** about preserving backward compatibility ."
"One problem with that approach is that\n\\_\\_file__ [is not necessarily defined for an executed script](http://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python).  Also, the relative pathname will fail if the cwd changes before the function call.  As suggested in one answer in that stackoverflow link, you could add a special locator module in the same directory, import that, and get its \\_\\_file__ attribute.  There are also solutions that use inspect.\n\nAssuming the directory path is correctly identified, the fact that imp.load_source always re-initializes modules could cause problems in more complicated cases."
"[Let's check on Google Trends](http://www.google.com/trends/explore#q=ruby%20tutorial%2C%20rails%20tutorial&amp;cmpt=q) : search on rails tutorial are about the same as on ruby tutorial.\n\nIndeed, the index would benefit from combining rails and ruby.  But their popularity is not growing. "
"belated response, but honestly given it's python here, I'd have to say: asyncio has been merged into python 3.4. It's become blessed by python-powers-that-be.  I quite like gevent, mind, but in python-land, that has to be a major consideration."
"Yes it has, though I think pulsar is the library framework I always wanted for python.\n\nThanks"
"pyNastran exists.  Now if you don't use Nastran, then you don't care, but it's a good library (I'm a bit biased) that's being adopted by NASA into OpenMDAO (their open source ModelCenter clone written in Python).  https://code.google.com/p/pynastran/\n\nOh yea...OpenMDAO www.openmdao.org\n\nand soon to be VSP written in C++ but soon to be swigged into Python http://www.openvsp.org/"
"&gt; Pyqtgraph - Matlab makes pretty plots, and is the standard plotting library\n\nI though Matplotlib was the standard?  Their webpage is better, the docs are better, they have more financial support, it supports Python 3, it has more functionality, what's worse (other than speed for GUI interaction, which even that can be made real time depending on data size if you stop updating the axis object every time you plot).  I thought PyQtGraph was only better for mass amounts of data."
"For your point about multitasking, most of the time, I don't really care about speed in python. If speed was critical, you would write it in C."
"&gt; their popularity is not growing\n\nWe can only hope. I can't believe that we (the programming community) seem to be doomed to repeat the same mistakes over and over. All these unmaintainable apps do though represent true job security."
"hmm. never used it, in fact wasn't aware of it. Mind you, an Actor model can be done in things layered on top of other apis though - in fact that's how I last used gevent, a partially-assed actor class that was a greenlet with a gevent queue as an inbox, pretty much [as per this stack overflow response by someone else](http://stackoverflow.com/a/3435125), then do the bulk of my actual domain modelling as actors. \n\n"
"I had been using a linux laptop. Lived it, but the wireless driver support was really bad. I've just bought a new laptop, may try to dual boot.\n\nI had been using Python with the assumption that the same code would work on a Linux server, no?"
"Thanks! Will check this out!"
"&gt; I had been using Python with the assumption that the same code would work on a Linux server, no?\n\nIt probably would, don't worry."
"Reworked from [here.](http://codegolf.stackexchange.com/a/17010)"
"Bad typing. I meant matplotlib, not matlab. Fixed.\n\nMatplotlib is the standard. But it's not great for realtime plotting. Try getting it to update ~20 fps with 10000 data points and scrolling axes. For static plots Matplotlib is unrivaled though."
"Update : The index has just been modified to combine searches on ruby and rails tutorial."
"What does it mean that `imp.load_source` always re-initializes modules? This part was not clear in the docs either. Can you give an example where it causes problems?"
"1. That does not make them any less first class.\n\n2. I doubt you can find three libraries that suffer from that problem."
"What do you mean \"bytestrings are gone\"?\n\nedit: I read your thing. I never realised python 3 was so broken."
"I (and Ian, I think) sees this issue from the perspective of a developer that uses Python and has written a lot of Python code. I've created code in Python that others find valuable (and so has Ian). But I believe we're not here for Python, Python's here for us. While we don't want to \"sabotage\" Python, our priorities are not primarily towards Python the language. Nor should they be, I think; we naturally care about our codebases and our work and the ecosystem surrounding that.\n\nThe problem with Python 3 is that a previously well aligned interest between the core developers and developers using the language has diverged. An interest in Python 3 adoption compared to an interest existing codebases that need to be maintained and evolved, and the ecosystem surrounding it. \n\nWhen Python 2.x was evolving in a backwards compatible manner, the interest of language evolution was more aligned with that of the developers already using the language in existing projects, but less so now.\n\nI'm a bit tired of non-starters concerning this whole discussion. Writing code compatible in both 2 and 3 was considered crazy talk and a non-starter when Python 3 was released. But people who wished the language well with existing codebases had to figure this out, as it was the only way forward to evolve codebases. In 2011 we've heard that Python 2.8 is a non-starter.\n"
"In your opinion, would a parallel course teaching both C and Python, finishing up with how to extend each with the other, be sufficient to address Python's academic deficits?"
"&gt; Try getting it to update ~20 fps with 10000 data points and scrolling axes\n\nI can do better than that.  It's work and you have to think about it differently and use all sorts of obscure (and occasionally buggy) interfaces, but it can be done.  The examples on the website will leave you with a very slow code. http://bastibe.de/2013-05-30-speeding-up-matplotlib.html"
"What on earth are you talking about?"
"It's funny you should mention that, because that is almost exactly like one of the things I suggested. This was supposed to address some of the issues we have in our third class - learning C++, version control, and Linux. My suggestion was to have a class in parallel with the second class in which you cover basic Linux, version control, and the basics of C++. This suggestion was independent of switching from Java to Python, though. With that method, I suppose Python would work fine for both the early classes. \n\nI apparently made a good case for that one, because that responsibility got off loaded to me. So now I get to teach basic Linux and git to first year undergrads.Yay me. "
"Still up from NYE is impressive :) Interestingly.. I used to think I preferred dynamic, \"non-declarative\" (which Matlab uses). Going to C# and needing to declare stuff seemed silly - \"Why can't it just figure out what it needs to be at runtime?\" \n\nHowever, the (mostly) static typing in C#.. now I'm starting to really dig it, for what it lets the IntelliSense do. "
"http://git-scm.com/book\n\nread it."
"I love Python. But this article is biased nonsense garbage."
"Numerical computing.  Python is dominant in the scientific community because it's easy, expressive, has great libraries, and easily interfaces with optimized C code.  The OO paradigm of Java maps poorly to the problems in this space and the lack of interactive computing makes it difficult for scientists to experiment. "
"&gt; If speed was critical, you would write it in C.\n\nFrom where I sit.. [vanilla] C is scary. \"Speed\" is definitely important to me - both speed of the guts of the number crunching, *but also implementing and getting it \"to market\"*. \n\nI feel like in say C# I can get code *done* extremely quickly, *and* have it be pretty sporty for calculations. "
"Very nice write-up, I appreciate it! Poor packaging is a bit of a scary prospect.\n\nMore on packaging... how about putting together GUI's / user interfaces? Definitely do-able in Matlab, though a bit clunky at times and not a huge selection of controls.\n\nHow about OOP support in Python? Good?"
"&gt; What's the point?\n\nThis:\n \n&gt; Python 3 is intentionally backwards incompatible. Even if such a layer was created, the same [...] people would NOT port their code to Python 3\n\nIf we can wrap legacy code in a compatibility layer, most people can move to Python 3/4 without discarding old, but trusted code. "
"It can be really tough finding a good metric for any thing.\nI think this is still a cool statistic to see and that its possible to deduce from it that, to some extent, the popularity of python over other languages is growing.\n\nHere is something I had fun with, trying to figure out how many begginners to intermidate users are by comparing \"current time\" function search: http://www.google.com/trends/explore#q=Php%20current%20time%2C%20C%20current%20time%2C%20Python%20current%20time%2C%20Perl%20current%20time%2C%20ruby%20current%20time&amp;cmpt=q"
